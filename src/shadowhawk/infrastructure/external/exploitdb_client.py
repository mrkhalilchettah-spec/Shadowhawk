"""
ExploitDB API Client.

Copyright (c) 2024 ShadowHawk Team
SPDX-License-Identifier: MIT
"""

import csv
import io
import logging
from typing import Any, Dict, List, Optional

import httpx
from tenacity import retry, stop_after_attempt, wait_exponential

from shadowhawk.core.config.settings import settings
from shadowhawk.core.utils.metrics import timed_api_call
from shadowhawk.core.utils.validation import extract_cve_id

logger = logging.getLogger(__name__)


class ExploitDBClient:
    """
    Client for ExploitDB (Offensive Security Exploit Database).
    
    Provides access to exploit information and searchable exploit data.
    """
    
    def __init__(self, base_url: Optional[str] = None):
        self.base_url = base_url or settings.external_api.exploitdb_url
        
        self.client = httpx.Client(
            timeout=settings.external_api.request_timeout,
            headers={
                "Accept": "text/csv",
                "User-Agent": "ShadowHawk-Platform/2.0.0",
            }
        )
        
        # Cache
        self._exploit_data: Optional[List[Dict]] = None
        self._cve_index: Dict[str, List[Dict]] = {}
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10)
    )
    def _fetch_exploit_data(self) -> List[Dict]:
        """Fetch exploit data from ExploitDB."""
        if self._exploit_data is not None:
            return self._exploit_data
        
        with timed_api_call("exploitdb"):
            logger.info("Fetching ExploitDB data...")
            response = self.client.get(self.base_url)
            response.raise_for_status()
            
            # Parse CSV
            csv_content = response.text
            reader = csv.DictReader(io.StringIO(csv_content))
            
            self._exploit_data = list(reader)
            self._build_cve_index()
            
            logger.info(f"Loaded {len(self._exploit_data)} exploits from ExploitDB")
            return self._exploit_data
    
    def _build_cve_index(self) -> None:
        """Build an index of exploits by CVE ID."""
        if not self._exploit_data:
            return
        
        self._cve_index = {}
        
        for exploit in self._exploit_data:
            # Check description for CVE IDs
            description = exploit.get("description", "")
            cve_id = extract_cve_id(description)
            
            if cve_id:
                cve_id = cve_id.upper()
                if cve_id not in self._cve_index:
                    self._cve_index[cve_id] = []
                self._cve_index[cve_id].append(exploit)
    
    def search_by_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by CVE ID.
        
        Args:
            cve_id: CVE ID (e.g., "CVE-2021-44228")
        
        Returns:
            List of matching exploits
        """
        self._fetch_exploit_data()
        
        cve_id = cve_id.upper()
        exploits = self._cve_index.get(cve_id, [])
        
        return [self._parse_exploit(e) for e in exploits]
    
    def search_by_keyword(self, keyword: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by keyword.
        
        Args:
            keyword: Search keyword
        
        Returns:
            List of matching exploits
        """
        self._fetch_exploit_data()
        
        keyword_lower = keyword.lower()
        matches = []
        
        for exploit in self._exploit_data:
            description = exploit.get("description", "").lower()
            if keyword_lower in description:
                matches.append(self._parse_exploit(exploit))
        
        return matches
    
    def search_by_type(self, exploit_type: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by type.
        
        Args:
            exploit_type: Exploit type (e.g., "remote", "local", "webapps")
        
        Returns:
            List of matching exploits
        """
        self._fetch_exploit_data()
        
        exploit_type_lower = exploit_type.lower()
        matches = []
        
        for exploit in self._exploit_data:
            if exploit.get("type", "").lower() == exploit_type_lower:
                matches.append(self._parse_exploit(exploit))
        
        return matches
    
    def search_by_platform(self, platform: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by platform.
        
        Args:
            platform: Platform name (e.g., "windows", "linux", "php")
        
        Returns:
            List of matching exploits
        """
        self._fetch_exploit_data()
        
        platform_lower = platform.lower()
        matches = []
        
        for exploit in self._exploit_data:
            if platform_lower in exploit.get("platform", "").lower():
                matches.append(self._parse_exploit(exploit))
        
        return matches
    
    def get_exploit_by_id(self, exploit_id: str) -> Optional[Dict[str, Any]]:
        """
        Get exploit by ExploitDB ID.
        
        Args:
            exploit_id: ExploitDB ID
        
        Returns:
            Exploit data or None
        """
        self._fetch_exploit_data()
        
        for exploit in self._exploit_data:
            if exploit.get("id") == exploit_id:
                return self._parse_exploit(exploit)
        
        return None
    
    def _parse_exploit(self, exploit: Dict) -> Dict[str, Any]:
        """Parse exploit data into standardized format."""
        description = exploit.get("description", "")
        cve_id = extract_cve_id(description)
        
        return {
            "exploit_id": exploit.get("id", ""),
            "file": exploit.get("file", ""),
            "description": description,
            "date_published": exploit.get("date_published", ""),
            "author": exploit.get("author", ""),
            "type": exploit.get("type", ""),
            "platform": exploit.get("platform", ""),
            "port": exploit.get("port", ""),
            "cve_id": cve_id,
            "exploit_url": f"https://www.exploit-db.com/exploits/{exploit.get('id', '')}",
        }
    
    def has_exploit(self, cve_id: str) -> bool:
        """
        Check if an exploit exists for a CVE.
        
        Args:
            cve_id: CVE ID
        
        Returns:
            True if exploit exists
        """
        exploits = self.search_by_cve(cve_id)
        return len(exploits) > 0
    
    def get_exploit_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about available exploits.
        
        Returns:
            Statistics dictionary
        """
        self._fetch_exploit_data()
        
        if not self._exploit_data:
            return {"total_exploits": 0}
        
        # Count by type
        type_counts = {}
        platform_counts = {}
        cves_with_exploits = len(self._cve_index)
        
        for exploit in self._exploit_data:
            # Type
            exploit_type = exploit.get("type", "unknown")
            type_counts[exploit_type] = type_counts.get(exploit_type, 0) + 1
            
            # Platform
            platform = exploit.get("platform", "unknown")
            platform_counts[platform] = platform_counts.get(platform, 0) + 1
        
        return {
            "total_exploits": len(self._exploit_data),
            "cves_with_exploits": cves_with_exploits,
            "by_type": type_counts,
            "by_platform": platform_counts,
        }
    
    def get_recent_exploits(self, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get most recent exploits.
        
        Args:
            limit: Number of exploits to return
        
        Returns:
            List of recent exploits
        """
        self._fetch_exploit_data()
        
        # Sort by date (newest first)
        sorted_exploits = sorted(
            self._exploit_data,
            key=lambda x: x.get("date_published", ""),
            reverse=True
        )
        
        return [self._parse_exploit(e) for e in sorted_exploits[:limit]]
    
    def close(self) -> None:
        """Close the HTTP client."""
        self.client.close()
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
